# Production values for PostgreSQL Helm Chart
# This file contains production-ready configurations with enhanced security and scalability

# Number of replicas for high availability
replicaCount: 1

# Use StatefulSet for stateful applications like databases
statefulset: true

# PostgreSQL specific configuration
postgresql:
  enabled: true
  pgdata: "/var/lib/postgresql/data/pgdata"
  passwordKey: "POSTGRES_PASSWORD"
  userKey: "POSTGRES_USER"
  databaseKey: "POSTGRES_DB"

# Persistence configuration with high-performance storage
persistence: 
  enabled: true
  volumeClaimTemplates:
    - name: postgres-storage
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: "fast-ssd"  # Use high-performance storage class
      resources:
        requests:
          storage: 100Gi

# Update strategy for StatefulSet
UpdateStrategy:
  type: RollingUpdate

# Container image configuration
image:
  registry: docker.io
  repository: postgres
  pullPolicy: IfNotPresent
  tag: "17-alpine"

# Service Account configuration with enhanced security
serviceAccount:
  create: true
  automount: false  # Disable automatic token mounting for security
  annotations: {}

# Enhanced security contexts
podSecurityContext: 
  fsGroup: 999
  runAsUser: 999
  runAsGroup: 999
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault
  supplementalGroups: [999]

securityContext:
  privileged: false
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 999
  runAsGroup: 999
  capabilities:
    drop:
    - ALL
    add:
    - CHOWN
    - DAC_OVERRIDE
    - FOWNER
    - SETGID
    - SETUID
  seccompProfile:
    type: RuntimeDefault

# Production resource limits and requests
resources:
  limits:
    cpu: 2000m
    memory: 4Gi
  requests:
    cpu: 500m
    memory: 1Gi

# Horizontal Pod Autoscaler for production
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
      - type: Pods
        value: 2
        periodSeconds: 60
      selectPolicy: Max

# Node selection for database nodes
nodeSelector:
  node-type: database
  kubernetes.io/arch: amd64

# Tolerations for database nodes
tolerations:
  - key: "database"
    operator: "Equal"
    value: "true"
    effect: "NoSchedule"

# High Availability configuration
highAvailability:
  enabled: true
  replicas: 3
  antiAffinity: "hard"  # Hard anti-affinity for maximum availability
  topologySpreadConstraints:
    enabled: true
    maxSkew: 1
    topologyKey: kubernetes.io/hostname
    whenUnsatisfiable: DoNotSchedule

# NetworkPolicy for network security
networkPolicy:
  enabled: true
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: default
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: postgresql
      ports:
        - protocol: TCP
          port: 5432
  egress:
    - {}  # Allow all egress traffic

# PodDisruptionBudget for availability
podDisruptionBudget:
  enabled: true
  minAvailable: 1  # Ensure at least 2 pods are always available

# Pod Security Standards
podSecurityStandards:
  enabled: true
  level: "restricted"

# Monitoring and observability
monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s
    scrapeTimeout: 10s
    labels:
      prometheus: kube-prometheus
  prometheusRule:
    enabled: true
    labels:
      prometheus: kube-prometheus
    rules: []

# Backup configuration for production
backup:
  enabled: true
  schedule: "0 2 * * *"  # Daily at 2 AM
  retention: "30d"  # Keep backups for 30 days
  storage:
    size: 50Gi
    storageClass: "fast-ssd"
  image:
    repository: postgres
    tag: "17-alpine"
    pullPolicy: IfNotPresent

# Enhanced health checks
probe:
  livenessProbe:
    exec:
      command:
        - /bin/sh
        - -c
        - exec pg_isready -U "$POSTGRES_USER" -d "$POSTGRES_DB" -h 127.0.0.1 -p 5432
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 10
    successThreshold: 1
    failureThreshold: 3
  readinessProbe:
    exec:
      command:
        - /bin/sh
        - -c
        - exec pg_isready -U "$POSTGRES_USER" -d "$POSTGRES_DB" -h 127.0.0.1 -p 5432
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3

# Service configuration
service:
  type: ClusterIP
  annotations: {}
  labels: {}
  servicePorts:
    - name: postgres
      port: 5432
      targetPort: 5432

# IMPORTANT: Set these values via external secret management in production
# Never hardcode passwords in values files
Secrets:
  POSTGRES_PASSWORD: ""  # Set via --set or external secret manager
  POSTGRES_USER: "postgres"
  POSTGRES_DB: "postgres"

# Additional environment variables for production
extraEnvs:
  - name: POSTGRES_INITDB_ARGS
    value: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
  - name: TZ
    value: "UTC"
  - name: POSTGRES_SHARED_PRELOAD_LIBRARIES
    value: "pg_stat_statements"

# Pod annotations for monitoring
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "5432"
  prometheus.io/path: "/metrics"

# Pod labels
podLabels:
  environment: production
  tier: database
