# Production values for PostgreSQL Helm Chart
# This file contains production-ready configurations with enhanced security and scalability

# Number of replicas for high availability
replicaCount: 1

# Use StatefulSet for stateful applications like databases
statefulset: true

# PostgreSQL specific configuration
postgresql:
  enabled: true
  pgdata: "/var/lib/postgresql/data/pgdata"
  passwordKey: "POSTGRES_PASSWORD"
  userKey: "POSTGRES_USER"
  databaseKey: "POSTGRES_DB"

# Persistence configuration
persistence: 
  enabled: true
  volumeClaimTemplates:
    - name: postgres-storage
      accessModes: [ "ReadWriteOnce" ]
      # storageClassName: ""  # Use default storage class
      resources:
        requests:
          storage: 100Gi

# Update strategy for StatefulSet
UpdateStrategy:
  type: RollingUpdate

# Container image configuration
image:
  registry: docker.io
  repository: postgres
  pullPolicy: IfNotPresent
  tag: "17-alpine"

# Service Account configuration with enhanced security
serviceAccount:
  create: true
  automount: false  # Disable automatic token mounting for security
  annotations: {}

# Enhanced security contexts
podSecurityContext: 
  fsGroup: 999
  runAsUser: 999
  runAsGroup: 999
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault
  supplementalGroups: [999]

securityContext:
  privileged: false
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 999
  runAsGroup: 999
  capabilities:
    drop:
    - ALL
    add:
    - CHOWN
    - DAC_OVERRIDE
    - FOWNER
    - SETGID
    - SETUID
  seccompProfile:
    type: RuntimeDefault

# Production resource limits and requests
resources:
  limits:
    cpu: 2000m
    memory: 4Gi
  requests:
    cpu: 500m
    memory: 1Gi

# Horizontal Pod Autoscaler for production
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
      - type: Pods
        value: 2
        periodSeconds: 60
      selectPolicy: Max

# Node selection (customize as needed)
nodeSelector: {}
  # node-type: database
  # kubernetes.io/arch: amd64

# Tolerations (customize as needed)
tolerations: []
  # - key: "database"
  #   operator: "Equal"
  #   value: "true"
  #   effect: "NoSchedule"

# High Availability configuration
highAvailability:
  enabled: true
  replicas: 3
  antiAffinity: "hard"  # Hard anti-affinity for maximum availability
  topologySpreadConstraints:
    enabled: true
    maxSkew: 1
    topologyKey: kubernetes.io/hostname
    whenUnsatisfiable: DoNotSchedule

# NetworkPolicy for network security
networkPolicy:
  enabled: true
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: default
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: postgresql
      ports:
        - protocol: TCP
          port: 5432
  egress:
    - {}  # Allow all egress traffic

# PodDisruptionBudget for availability
podDisruptionBudget:
  enabled: true
  minAvailable: 1  # Ensure at least 2 pods are always available

# Pod Security Standards
podSecurityStandards:
  enabled: true
  level: "restricted"

# Monitoring and observability
monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s
    scrapeTimeout: 10s
    labels:
      prometheus: kube-prometheus
  prometheusRule:
    enabled: true
    labels:
      prometheus: kube-prometheus
    rules: []

# Backup configuration (disabled - using external backup solution)
backup:
  enabled: false
  schedule: "0 2 * * *"  # Daily at 2 AM
  retention: "30d"  # Keep backups for 30 days
  storage:
    size: 50Gi
    storageClass: ""
  image:
    repository: postgres
    tag: "17-alpine"
    pullPolicy: IfNotPresent

# Enhanced health checks
probe:
  livenessProbe:
    exec:
      command:
        - /bin/sh
        - -c
        - exec pg_isready -U "$POSTGRES_USER" -d "$POSTGRES_DB" -h 127.0.0.1 -p 5432
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 10
    successThreshold: 1
    failureThreshold: 3
  readinessProbe:
    exec:
      command:
        - /bin/sh
        - -c
        - exec pg_isready -U "$POSTGRES_USER" -d "$POSTGRES_DB" -h 127.0.0.1 -p 5432
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3

# Service configuration
service:
  type: ClusterIP
  annotations: {}
  labels: {}
  servicePorts:
    - name: postgres
      port: 5432
      targetPort: 5432

# IMPORTANT: Set these values via external secret management in production
# Never hardcode passwords in values files
Secrets:
  POSTGRES_PASSWORD: ""  # Set via --set or external secret manager
  POSTGRES_USER: "postgres"
  POSTGRES_DB: "postgres"

# Additional environment variables for production
extraEnvs:
  - name: POSTGRES_INITDB_ARGS
    value: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
  - name: TZ
    value: "UTC"
  - name: POSTGRES_SHARED_PRELOAD_LIBRARIES
    value: "pg_stat_statements"

# Pod annotations for monitoring
podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "5432"
  prometheus.io/path: "/metrics"

# Pod labels
podLabels:
  environment: production
  tier: database

# Extra environment variables
extraEnvs: []
# - name: POSTGRES_INITDB_ARGS
#   value: "--encoding=UTF-8 --lc-collate=C --lc-ctype=C"
# - name: TZ
#   value: "America/Sao_Paulo"

# Load environment variables from ConfigMap or Secret
envFrom: []
# - configMapRef:
#     name: postgres-config
# - secretRef:
#     name: postgres-secret

# ConfigMap mounts - mount ConfigMap as files
configMounts: []
# - name: postgres-config
#   configName: postgres-config
#   path: /etc/postgresql/postgresql.conf
#   subPath: postgresql.conf

# Secret mounts - mount Secret as files
secretMounts: []
# - name: postgres-certs
#   secretName: postgres-tls-secret
#   path: /etc/ssl/certs
#   subPath: tls.crt

# Custom secret name (if empty, will be generated as "<release-name>-secret")
secretName: ""

# Main ConfigMap data
ConfigMap: {}
# postgresql.conf: |
#   listen_addresses = '*'
#   max_connections = 100
#   shared_buffers = 128MB

# Extra volumes and volume mounts
extraVolumeMounts: []
# - name: custom-config
#   mountPath: /etc/postgresql/custom.conf
#   subPath: custom.conf

extraVolumes: []
# - name: custom-config
#   configMap:
#     name: postgres-custom-config

# Extra secrets configuration
extraSecrets:
  enabled: false
  name: ""  # Will be generated as "<release-name>-extra-secret" if empty
  data: {}
  # username: dXNlcm5hbWU=  # base64 encoded values
  # password: cGFzc3dvcmQ=

# Extra ConfigMap configuration  
extraConfigMap: 
  enabled: false
  name: ""  # Will be generated as "<release-name>-extra-configmap" if empty
  data: {}
  # config.yaml: |
  #   key: value
  # script.sh: |
  #   #!/bin/bash
  #   echo "Hello World"

# Container ports
containerPorts:
  - name: postgres
    containerPort: 5432
    protocol: TCP

# Image pull secrets for private registries
imagePullSecrets: []
# - name: myregistrykey

# Override the chart name
nameOverride: ""
fullnameOverride: ""

# Additional labels for Deployment/StatefulSet
labels: {}
  # environment: production
  # team: database

# Command and args override
command: []
# - "docker-entrypoint.sh"
args: []
# - "postgres"

# Extra containers (sidecars)
extraContainers: []
# - name: postgres-exporter
#   image: prometheuscommunity/postgres-exporter:latest
#   env:
#     - name: DATA_SOURCE_NAME
#       value: "postgresql://$(POSTGRES_USER):$(POSTGRES_PASSWORD)@localhost:5432/$(POSTGRES_DB)?sslmode=disable"
#   ports:
#     - name: metrics
#       containerPort: 9187

# Extra init containers
extraInitContainers: []
# - name: postgres-init
#   image: postgres:17-alpine
#   command: ["sh", "-c"]
#   args:
#     - |
#       echo "Initializing database..."
#       # Custom initialization logic here

# CronJobs configuration
CronJobs: []
# - name: postgres-backup
#   schedule: "0 2 * * *"
#   image:
#     repository: postgres
#     tag: "17-alpine"
#     imagePullPolicy: IfNotPresent
#   command: ["sh"]
#   args:
#     - -c
#     - |
#       pg_dump -h postgres-service -U $POSTGRES_USER $POSTGRES_DB > /backup/backup-$(date +%Y%m%d-%H%M%S).sql
#   env:
#     - name: POSTGRES_USER
#       valueFrom:
#         secretKeyRef:
#           name: postgres-secret
#           key: POSTGRES_USER
#   volumeMounts:
#     - name: backup-storage
#       mountPath: /backup
#   volumes:
#     - name: backup-storage
#       persistentVolumeClaim:
#         claimName: postgres-backup-pvc
#   restartPolicy: OnFailure
#   concurrencyPolicy: Forbid
#   successfulJobsHistoryLimit: 3
#   failedJobsHistoryLimit: 1

# Ingress configuration
ingress:
  enabled: false
  ingressClassName: ""  # nginx, traefik, etc.
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # nginx.ingress.kubernetes.io/tcp-services-configmap: default/tcp-services
  labels: {}
  hosts: []
  # - host: postgres.example.com
  #   paths:
  #   - path: /
  #     pathType: Prefix
  #     number: 5432
  tls: []
  # - secretName: postgres-tls-secret
  #   hosts:
  #     - postgres.example.com
